name: iOS IPA (Sideloadly)

on:
  workflow_dispatch:
    inputs:
      export_method:
        description: Export method (adhoc or development)
        default: adhoc
        required: true
      # Scheme is fixed in this repo; change in code if needed

jobs:
  build:
    runs-on: macos-14
    env:
      APP_PROJECT: NotesApp.xcodeproj
      APP_SCHEME: NotesApp
      EXPORT_METHOD: ${{ github.event.inputs.export_method || 'adhoc' }}
      BUNDLE_ID: com.venki18.codesnake
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode 15.4
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '15.4'

      - name: Fetch Pyodide runtime assets
        shell: bash
        env:
          PYODIDE_VERSION: ${{ vars.PYODIDE_VERSION }}
        run: |
          set -euo pipefail
          DEST="NotesApp/PyodideAssets"
          mkdir -p "$DEST"
          if [ -f "$DEST/pyodide.js" ]; then echo "Pyodide assets already present"; exit 0; fi
          VER="${PYODIDE_VERSION:-0.24.1}"
          URL="https://github.com/pyodide/pyodide/releases/download/${VER}/pyodide-${VER}.tar.bz2"
          TMP=$(mktemp -d)
          echo "Downloading Pyodide ${VER}â€¦"; curl -L "$URL" -o "$TMP/pyodide.tar.bz2"
          tar -xjf "$TMP/pyodide.tar.bz2" -C "$TMP"
          rsync -a "$TMP/pyodide/" "$DEST/"
          ls -la "$DEST" | head -n 10

      - name: Precheck signing secrets (p12 + password)
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${{ secrets.IOS_CERT_P12_BASE64 || '' }}" ]]; then echo "::error::IOS_CERT_P12_BASE64 is missing"; exit 1; fi
          if [[ -z "${{ secrets.IOS_CERT_PASSWORD || '' }}" ]]; then echo "::error::IOS_CERT_PASSWORD is missing"; exit 1; fi
          TMP_DIR=$(mktemp -d)
          echo "Validating p12 secret..."
          echo "${{ secrets.IOS_CERT_P12_BASE64 }}" | base64 --decode > "$TMP_DIR/signing.p12" || { echo "::error::Invalid base64 in IOS_CERT_P12_BASE64"; exit 1; }
          # Validate password and structure: read certs OK
          if ! (openssl pkcs12 -in "$TMP_DIR/signing.p12" -passin pass:"${{ secrets.IOS_CERT_PASSWORD }}" -nokeys -clcerts -info -nodes >/dev/null 2>&1); then
            echo "::error::p12 password incorrect or file corrupted"; exit 1
          fi
          # Ensure a private key exists in the PKCS#12 bundle
          if ! (openssl pkcs12 -in "$TMP_DIR/signing.p12" -passin pass:"${{ secrets.IOS_CERT_PASSWORD }}" -nocerts -nodes -out /dev/null >/dev/null 2>&1); then
            echo "::error::p12 does not contain a private key. Re-export .p12 from 'My Certificates' including the private key, or rebuild with openssl -export -inkey <key> -in <cert>."; exit 1
          fi
          echo "p12 precheck OK ($(/usr/bin/stat -f%z "$TMP_DIR/signing.p12" 2>/dev/null || stat -f%z "$TMP_DIR/signing.p12" 2>/dev/null || stat -f "%z" "$TMP_DIR/signing.p12" 2>/dev/null || stat -c%s "$TMP_DIR/signing.p12" ) bytes)"

      - name: Precheck provisioning profile (type + bundle id)
        shell: bash
        env:
          PROFILE_B64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
        run: |
          set -euo pipefail
          if [[ -z "${PROFILE_B64:-}" ]]; then
            echo "::error::Missing IOS_PROVISION_PROFILE_BASE64 secret."; exit 1
          fi
          TMP=$(mktemp -d)
          echo "$PROFILE_B64" | base64 --decode > "$TMP/profile.mobileprovision" || { echo "::error::Invalid base64 in IOS_PROVISION_PROFILE_BASE64"; exit 1; }
          PLIST="$TMP/profile.plist"
          /usr/bin/security cms -D -i "$TMP/profile.mobileprovision" > "$PLIST"
          NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$PLIST")
          UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$PLIST")
          APPID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' "$PLIST")
          GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:get-task-allow' "$PLIST" 2>/dev/null || echo false)
          if /usr/libexec/PlistBuddy -c 'Print :ProvisionedDevices' "$PLIST" >/dev/null 2>&1; then HAS_DEVICES=true; else HAS_DEVICES=false; fi
          # Validate bundle id/prefix
          SUFFIX="${APPID#*.}"
          PREFIX="${APPID%%.*}"
          if [[ "$SUFFIX" != "$BUNDLE_ID" ]]; then
            echo "::error::Profile app id ($SUFFIX) does not match bundle id ($BUNDLE_ID)"; exit 1
          fi
          if [[ -n "${{ secrets.IOS_TEAM_ID }}" && "$PREFIX" != "${{ secrets.IOS_TEAM_ID }}" ]]; then
            echo "::warning::Profile team prefix ($PREFIX) differs from IOS_TEAM_ID (${{ secrets.IOS_TEAM_ID }})";
          fi
          # Validate type by export method
          case "$EXPORT_METHOD" in
            adhoc)
              if [[ "$GET_TASK_ALLOW" != "false" || "$HAS_DEVICES" != "true" ]]; then
                echo "::error::Ad Hoc expected: get-task-allow=false and ProvisionedDevices present. Got get-task-allow=$GET_TASK_ALLOW, ProvisionedDevices=$HAS_DEVICES"; exit 1
              fi
              ;;
            development)
              if [[ "$GET_TASK_ALLOW" != "true" || "$HAS_DEVICES" != "true" ]]; then
                echo "::error::Development expected: get-task-allow=true and ProvisionedDevices present. Got get-task-allow=$GET_TASK_ALLOW, ProvisionedDevices=$HAS_DEVICES"; exit 1
              fi
              ;;
            *)
              echo "::warning::Unsupported EXPORT_METHOD=$EXPORT_METHOD for sideload; continuing"
              ;;
          esac
          echo "Profile OK: $NAME ($UUID) for $APPID; get-task-allow=$GET_TASK_ALLOW; devices=$HAS_DEVICES"

      - name: Import signing certs
        id: certs
        uses: apple-actions/import-codesign-certs@v2
        with:
          p12-file-base64: ${{ secrets.IOS_CERT_P12_BASE64 }}
          p12-password: ${{ secrets.IOS_CERT_PASSWORD }}

      - name: Show available code signing identities (debug)
        run: /usr/bin/security find-identity -v -p codesigning

      - name: Install provisioning profile(s)
        shell: bash
        env:
          PROFILE_B64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
        run: |
          set -euo pipefail
          mkdir -p "${HOME}/Library/MobileDevice/Provisioning Profiles"
          if [[ -z "${PROFILE_B64:-}" ]]; then
            echo "::error::Missing IOS_PROVISION_PROFILE_BASE64 secret."; exit 1
          fi
          TMP=$(mktemp -d)
          echo "$PROFILE_B64" | base64 --decode > "$TMP/profile.mobileprovision"
          # Extract Name and UUID to place the file where Xcode expects it
          PLIST="$TMP/profile.plist"
          /usr/bin/security cms -D -i "$TMP/profile.mobileprovision" > "$PLIST"
          NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$PLIST")
          UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$PLIST")
          echo "Profile: $NAME ($UUID)"
          cp "$TMP/profile.mobileprovision" "${HOME}/Library/MobileDevice/Provisioning Profiles/${UUID}.mobileprovision"
          echo "PROFILE_NAME=$NAME" >> $GITHUB_ENV
          echo "PROFILE_UUID=$UUID" >> $GITHUB_ENV

      - name: Resolve bundle id and team
        run: |
          echo "Using bundle id: $BUNDLE_ID"
          if [[ -z "${{ secrets.IOS_TEAM_ID }}" ]]; then echo "::warning::IOS_TEAM_ID secret not set; build may fail"; fi

      - name: Install xcpretty
        run: sudo gem install xcpretty -N || true

      - name: Build archive
        shell: bash
        run: |
          set -euo pipefail
          ARCHIVE_PATH="$RUNNER_TEMP/NotesApp.xcarchive"
          # Choose a signing identity by export method
          if [[ "$EXPORT_METHOD" == "adhoc" || "$EXPORT_METHOD" == "app-store" ]]; then
            IDENTITY="Apple Distribution"
          else
            IDENTITY="Apple Development"
          fi
          xcodebuild -version
          xcodebuild -list -project "$APP_PROJECT"
          xcodebuild \
            -project "$APP_PROJECT" \
            -scheme "$APP_SCHEME" \
            -configuration Release \
            -archivePath "$ARCHIVE_PATH" \
            DEVELOPMENT_TEAM=${{ secrets.IOS_TEAM_ID }} \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="$IDENTITY" \
            PROVISIONING_PROFILE_SPECIFIER="$PROFILE_NAME" \
            OTHER_CODE_SIGN_FLAGS="--keychain ${{ steps.certs.outputs.keychain-path }}" \
            archive | xcpretty || exit ${PIPESTATUS[0]}
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> $GITHUB_ENV

      - name: Create export options
        shell: bash
        run: |
          set -euo pipefail
          PLIST="$RUNNER_TEMP/exportOptions.plist"
          cat > "$PLIST" <<'PL'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>${EXPORT_METHOD}</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>destination</key>
            <string>export</string>
            <key>compileBitcode</key>
            <false/>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key>
              <string>${PROFILE_NAME}</string>
            </dict>
            <key>stripSwiftSymbols</key>
            <true/>
            <key>teamID</key>
            <string>${{ secrets.IOS_TEAM_ID }}</string>
          </dict>
          </plist>
          PL
          # Expand vars in place
          sed -i '' "s|\${EXPORT_METHOD}|$EXPORT_METHOD|g" "$PLIST"
          sed -i '' "s|\${BUNDLE_ID}|$BUNDLE_ID|g" "$PLIST"
          sed -i '' "s|\${PROFILE_NAME}|$PROFILE_NAME|g" "$PLIST"
          echo "EXPORT_PLIST=$PLIST" >> $GITHUB_ENV

      - name: Export IPA
        shell: bash
        run: |
          set -euo pipefail
          OUT="$RUNNER_TEMP/ipa"
          mkdir -p "$OUT"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportOptionsPlist "$EXPORT_PLIST" \
            -exportPath "$OUT" | xcpretty || exit ${PIPESTATUS[0]}
          ls -la "$OUT"
          # Normalize filename for convenience with Sideloadly
          IPA=$(ls -1 "$OUT"/*.ipa | head -n1)
          if [[ -f "$IPA" ]]; then
            mv "$IPA" "$OUT/CodeSnake-${EXPORT_METHOD}.ipa"
          fi
          echo "IPA_DIR=$OUT" >> $GITHUB_ENV

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: codesnake-ipa
          path: ${{ env.IPA_DIR }}/*.ipa
          if-no-files-found: error
