name: iOS App Store Build v3 (No Upload)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment name for environment-scoped secrets"
        required: false
        default: "prod"
      export_method:
        description: "Export method: app-store-connect | ad-hoc | development"
        required: false
        default: "app-store-connect"

jobs:
  release:
    name: Build, Sign and Export IPA (No Upload)
    runs-on: macos-latest
    environment:
      name: ${{ inputs.environment }}
    env:
      BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
      P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}
      IOS_TEAM_ID: ${{ secrets.IOS_TEAM_ID }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Show Xcode version
      run: xcodebuild -version

    - name: Install SwiftLint
      run: brew install swiftlint

    - name: Lint Swift code (non-blocking)
      run: swiftlint --reporter github-actions-logging || true

    # Download prebuilt Python.xcframework and stdlib into project paths,
    # and mirror to ThirdParty/Python for downstream steps.
    - name: Fetch Python runtime (xcframework + stdlib)
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PY_SUPPORT_REPO: beeware/Python-Apple-support
        PY_SUPPORT_TAG: latest
        PY_TARGET_XCF_DIR: ios/Frameworks/Python.xcframework
        PY_TARGET_STDLIB: Resources/python-stdlib.zip
      run: bash scripts/fetch_python_runtime.sh

    - name: Verify runtime files exist pre-archive
      shell: bash
      run: |
        set -e
        ls -lah ios/Frameworks/Python.xcframework || { echo "::error::Missing ios/Frameworks/Python.xcframework"; exit 1; }
        ls -lah Resources/python-stdlib.zip || { echo "::error::Missing Resources/python-stdlib.zip"; exit 1; }

    - name: Enforce version alignment
      shell: bash
      env:
        EXPECTED_PY_PREFIX: "3.14"
        PY_SUPPORT_TAG: ${{ env.PY_SUPPORT_TAG || '3.14-b8' }}
      run: |
        set -e
        # 1) Ensure the Apple-support tag matches expected major.minor
        case "$PY_SUPPORT_TAG" in
          ${EXPECTED_PY_PREFIX}*) ;; \
          *) echo "Tag $PY_SUPPORT_TAG does not match ${EXPECTED_PY_PREFIX}*"; exit 1;; \
        esac
        # 2) Ensure stdlib zip advertises the same major.minor
        unzip -p Resources/python-stdlib.zip PYTHON_VERSION.txt > ver.txt || { echo "PYTHON_VERSION.txt missing"; exit 1; }
        VER=$(cut -d. -f1-2 ver.txt)
        [ "$VER" = "$EXPECTED_PY_PREFIX" ] || { echo "stdlib $VER != $EXPECTED_PY_PREFIX"; exit 1; }

    # CPython embedding: fallback fetch via support tarball (only if not present)
    - name: Fetch CPython runtime (Python-Apple-support 3.14-b8)
      shell: bash
      run: |
        # Skip if artifacts already present
        if [ -d ThirdParty/Python/Python.xcframework ] && [ -f ThirdParty/Python/python-stdlib.zip ]; then
          echo "Python runtime already prepared; skipping fallback download"
          exit 0
        fi
        set -euo pipefail
        SUPPORT_URL="https://github.com/beeware/Python-Apple-support/releases/download/3.14-b8/Python-3.14-iOS-support.b8.tar.gz"
        mkdir -p ThirdParty/Python
        cd ThirdParty/Python
        echo "Downloading: $SUPPORT_URL"
        curl -L "$SUPPORT_URL" -o python-ios-support.tar.gz
        tar -xzf python-ios-support.tar.gz
        echo "Extracted contents:"; find . -maxdepth 3 -mindepth 1 -print
        # Locate xcframework and stdlib zip inside extracted tree
        XCF=$(find . -maxdepth 6 -type d -name "*.xcframework" | head -n1 || true)
        if [ -n "$XCF" ]; then
          # If it's already named and located at ./Python.xcframework, keep it; otherwise, normalize
          if [ "$(basename "$XCF")" = "Python.xcframework" ] && [ "$(cd "$(dirname "$XCF")" && pwd)" = "$(pwd)" ]; then
            echo "Python.xcframework already in place"
          else
            rm -rf Python.xcframework || true
            mv "$XCF" Python.xcframework
          fi
        else
          echo "::warning title=CPython::No *.xcframework found in support package"
        fi
        STDLIB=$(find . -maxdepth 6 -type f \( -name "*stdlib*.zip" -o -name "python-stdlib.zip" -o -name "stdlib.zip" \) | head -n1 || true)
        if [ -n "$STDLIB" ]; then
          cp "$STDLIB" python-stdlib.zip
        else
          echo "::warning title=CPython::No stdlib zip found in support package"
        fi
        # Locate headers and static library (fallback if no xcframework)
        HDR=$(find . -maxdepth 6 -type f -name Python.h | head -n1 || true)
        if [ -n "$HDR" ]; then echo "Found Python.h: $HDR"; fi
        # Prefer static lib in device slice if available
        LIBA=$(find Python.xcframework/ios-arm64 -type f -name "libpython*.a" 2>/dev/null | head -n1 || true)
        if [ -z "$LIBA" ]; then
          LIBA=$(find . -maxdepth 8 -type f -name "libpython*.a" | head -n1 || true)
        fi
        if [ -n "$LIBA" ]; then echo "Found static lib: $LIBA"; fi
        # Write helper vars for later steps
        # Determine framework search dir (device slice preferred) and include dir
        FW_DIR=""
        if [ -d Python.xcframework ]; then
          if [ -d Python.xcframework/ios-arm64 ]; then FW_DIR="$(pwd)/Python.xcframework/ios-arm64"; fi
          if [ -z "$FW_DIR" ]; then
            CAND=$(find Python.xcframework -maxdepth 3 -type d -name "*.framework" | head -n1 || true)
            if [ -n "$CAND" ]; then FW_DIR="$(cd "$(dirname "$CAND")" && pwd)"; fi
          fi
        fi
        INC_DIR=""
        if [ -d Python.xcframework/ios-arm64/include ]; then INC_DIR="$(pwd)/Python.xcframework/ios-arm64/include"; fi
        {
          echo "PY_HDR=$HDR";
          echo "PY_LIBA=$LIBA";
          echo "PY_XCF=$XCF";
          echo "PY_FW_DIR=$FW_DIR";
          echo "PY_INC_DIR=$INC_DIR";
        } >> $GITHUB_ENV
    - name: Prepare App Icons from master (no placeholders)
      run: |
        if [ ! -f branding/app_icon_1024.png ] && [ -z "$APP_ICON_MASTER" ]; then
          echo "No master icon provided; generating a default branded icon";
          python3 scripts/make_master_icon.py || true;
        fi
        APP_ICON_MASTER=${APP_ICON_MASTER:-branding/app_icon_1024.png}
        if [ -f "$APP_ICON_MASTER" ]; then
          python3 scripts/prepare_app_icons_from_master.py || true
        fi

    - name: Compute unique build number
      run: |
        NEW_BUILD=$(date +%Y%m%d%H%M)
        echo "NEW_BUILD=$NEW_BUILD" >> $GITHUB_ENV
        echo "::notice title=Build Number::CFBundleVersion will be $NEW_BUILD"

    - name: Preflight - Check required secrets presence
      run: |
        check() { if [ -z "$1" ]; then echo "::error title=Missing secret::${2} not set"; exit 1; else echo "${2}: present"; fi }
        echo "Environment: ${{ inputs.environment }}"
        check "${BUILD_CERTIFICATE_BASE64}" "BUILD_CERTIFICATE_BASE64"
        check "${P12_PASSWORD}" "P12_PASSWORD"
        check "${KEYCHAIN_PASSWORD}" "KEYCHAIN_PASSWORD"
        check "${BUILD_PROVISION_PROFILE_BASE64}" "BUILD_PROVISION_PROFILE_BASE64"

    - name: Install Apple Certificate
      run: |
        CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH

    - name: Install Provisioning Profile
      run: |
        PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
        echo -n "$BUILD_PROVISION_PROFILE_BASE64" | base64 --decode -o $PP_PATH
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles
        echo "PP_PATH=$PP_PATH" >> $GITHUB_ENV
        security cms -D -i $PP_PATH > $RUNNER_TEMP/profile.plist
        PP_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' $RUNNER_TEMP/profile.plist)
        PP_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' $RUNNER_TEMP/profile.plist)
        echo "Using Provisioning Profile: $PP_NAME ($PP_UUID)"
        echo "PP_UUID=$PP_UUID" >> $GITHUB_ENV
        echo "PP_NAME=$PP_NAME" >> $GITHUB_ENV

    - name: Build and Archive (Release - unsigned)
      run: |
        build_with_flags() {
          echo "xcodebuild flags: $*"
          # capture full output to a log for debugging
          xcodebuild archive \
            -project NotesApp.xcodeproj \
            -scheme NotesApp \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            -archivePath ${{ runner.temp }}/CodeSnake-Release.xcarchive \
            CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO \
            CURRENT_PROJECT_VERSION=$NEW_BUILD \
            "$@" 2>&1 | tee "$RUNNER_TEMP/build.log"
          return ${PIPESTATUS[0]}
        }

        # Prefer static linking first if a static lib exists (avoids framework module complexities)
        if [ -n "${PY_LIBA:-}" ]; then
          echo "Using static library: $PY_LIBA"
          ST_FLAGS=(
            "HEADER_SEARCH_PATHS=${PY_INC_DIR:-$PWD/ThirdParty/Python/Python.xcframework/ios-arm64/include}"
            "LIBRARY_SEARCH_PATHS=${PY_LIB_DIR:-$PWD/ThirdParty/Python/Python.xcframework/ios-arm64/lib}"
            "OTHER_LDFLAGS=$PY_LIBA"
            "GCC_PREPROCESSOR_DEFINITIONS=EXPECTED_PYVER_PREFIX=\\\"${EXPECTED_PY_PREFIX:-3.14}\\\""
            "ONLY_ACTIVE_ARCH=YES"
            "CLANG_TREAT_WARNINGS_AS_ERRORS=NO"
            "CLANG_ENABLE_MODULES=NO"
            "OTHER_CFLAGS=-Wno-quoted-include-in-framework-header -fno-modules"
          )
          build_with_flags "${ST_FLAGS[@]}"
        elif [ -d ThirdParty/Python/Python.xcframework ]; then
          # Dynamic framework path (device slice)
          DYN_FLAGS=()
          # Prefer device include dir to avoid module.map usage in framework headers
          DYN_FLAGS+=("HEADER_SEARCH_PATHS=${PY_INC_DIR:-$PWD/ThirdParty/Python/Python.xcframework/ios-arm64/include}")
          DYN_FLAGS+=("FRAMEWORK_SEARCH_PATHS=${PY_FW_DIR:-$PWD/ThirdParty/Python}")
          # Pass framework flags via linker to satisfy swift/clang drivers consistently
          DYN_FLAGS+=("OTHER_LDFLAGS=-Xlinker -framework -Xlinker Python")
          DYN_FLAGS+=("GCC_PREPROCESSOR_DEFINITIONS=EXPECTED_PYVER_PREFIX=\\\"${EXPECTED_PY_PREFIX:-3.14}\\\"")
          DYN_FLAGS+=("CLANG_TREAT_WARNINGS_AS_ERRORS=NO")
          DYN_FLAGS+=("CLANG_ENABLE_MODULES=NO")
          DYN_FLAGS+=("OTHER_CFLAGS=-Wno-quoted-include-in-framework-header -fno-modules")
          DYN_FLAGS+=("LD_RUNPATH_SEARCH_PATHS=@executable_path/Frameworks")
          DYN_FLAGS+=("ONLY_ACTIVE_ARCH=YES")
          echo "Using XCFramework linking (-framework Python) with device include headers"

          set +e
          build_with_flags "${DYN_FLAGS[@]}"; RC=$?
          set -e
          if [ $RC -ne 0 ]; then
            echo "::error title=CPython::Dynamic link failed and no static lib available"
            echo "--- Last 300 lines of build log ---"
            tail -n 300 "$RUNNER_TEMP/build.log" || true
            exit $RC
          fi
        else
          echo "::error title=CPython::No xcframework or static lib found in support package"
          exit 1
        fi

    - name: Upload build log on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: build-log
        path: ${{ runner.temp }}/build.log

    - name: Inject CPython artifacts into app bundle (if present)
      run: |
        ARCHIVE_DIR='${{ runner.temp }}/CodeSnake-Release.xcarchive'
        if [ ! -d "$ARCHIVE_DIR" ]; then echo "No archive dir found: $ARCHIVE_DIR"; exit 0; fi
        APP_DIR=$(find "$ARCHIVE_DIR" -type d -name "*.app" -maxdepth 4 | head -n 1 || true)
        if [ -z "$APP_DIR" ]; then echo "No app bundle found to inject"; exit 0; fi
        # Copy stdlib zip
        if [ -f ThirdParty/Python/python-stdlib.zip ]; then
          cp ThirdParty/Python/python-stdlib.zip "$APP_DIR/"
          echo "Injected python-stdlib.zip into app bundle"
        fi
        # Copy Python.framework from xcframework slice (device) if it exists
        if [ -d ThirdParty/Python/Python.xcframework ]; then
          FW_SRC=$(ls -d ThirdParty/Python/Python.xcframework/ios-arm64/Python.framework 2>/dev/null || true)
          if [ -z "$FW_SRC" ]; then
            # fallback: any Python.framework inside xcframework
            FW_SRC=$(ls -d ThirdParty/Python/Python.xcframework/*/Python.framework 2>/dev/null | head -n1 || true)
          fi
          if [ -n "$FW_SRC" ]; then
            mkdir -p "$APP_DIR/Frameworks"
            rsync -a "$FW_SRC/" "$APP_DIR/Frameworks/Python.framework/"
            echo "Injected Python.framework into app bundle Frameworks"
          else
            echo "No Python.framework found to inject"
          fi
        fi

    - name: Extract App Metadata (version/build/bundle)
      run: |
        ARCHIVE_DIR='${{ runner.temp }}/CodeSnake-Release.xcarchive'
        APP_DIR=$(find "$ARCHIVE_DIR" -type d -name "*.app" -maxdepth 4 | head -n 1)
        PLIST="$APP_DIR/Info.plist"
        if [ ! -f "$PLIST" ]; then echo "::error title=Info.plist not found::$PLIST"; exit 1; fi
        APP_VERSION=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$PLIST")
        APP_BUILD=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$PLIST")
        BUNDLE_ID=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleIdentifier' "$PLIST")
        echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
        echo "APP_BUILD=$APP_BUILD" >> $GITHUB_ENV
        echo "BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV
        echo "::notice title=Build Metadata::BundleID=$BUNDLE_ID Version=$APP_VERSION Build=$APP_BUILD"

    - name: Generate Export Options (manual with profile UUID)
      run: |
        TEAM_ID="${IOS_TEAM_ID}"
        if [ -z "$TEAM_ID" ]; then TEAM_ID=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' $RUNNER_TEMP/profile.plist 2>/dev/null || true); fi
        METHOD="${{ inputs.export_method }}"; if [ -z "$METHOD" ]; then METHOD="${{ vars.EXPORT_METHOD }}"; fi; if [ -z "$METHOD" ]; then METHOD="app-store-connect"; fi
        cat > $RUNNER_TEMP/export-options.plist <<EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>${METHOD}</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>teamID</key>
            <string>${TEAM_ID}</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
                <key>${BUNDLE_ID}</key>
                <string>${PP_NAME}</string>
            </dict>
            <key>stripSwiftSymbols</key>
            <true/>
            <key>uploadSymbols</key>
            <false/>
        </dict>
        </plist>
        EOF

    - name: Export Signed IPA
      run: |
        xcodebuild -exportArchive \
          -archivePath ${{ runner.temp }}/CodeSnake-Release.xcarchive \
          -exportPath ${{ runner.temp }}/export-release \
          -exportOptionsPlist $RUNNER_TEMP/export-options.plist
        IPA_PATH=$(ls ${{ runner.temp }}/export-release/*.ipa | head -n 1)
        if [ -z "$IPA_PATH" ]; then echo "::error title=Export failed::No IPA produced"; exit 1; fi
        echo "IPA_PATH=$IPA_PATH" >> $GITHUB_ENV
        echo "::notice title=Export Complete::IPA=$(basename "$IPA_PATH") BundleID=$BUNDLE_ID Version=$APP_VERSION Build=$APP_BUILD"

    - name: Upload Signed IPA as Artifact
      uses: actions/upload-artifact@v4
      with:
        name: CodeSnake-Release-IPA
        path: ${{ runner.temp }}/export-release/*.ipa
        retention-days: 30

    - name: Verify embedded provisioning in IPA
      if: success()
      shell: bash
      run: |
        set -e
        IPA=$(ls ${{ runner.temp }}/export-release/*.ipa | head -n 1)
        TMP=$(mktemp -d)
        unzip -q "$IPA" -d "$TMP"
        APPDIR=$(ls -d "$TMP"/Payload/*.app)
        # TEAM_ID from secret or derived earlier; BUNDLE_ID already extracted
        TEAM_ID_VAR="${IOS_TEAM_ID}"
        if [ -z "$TEAM_ID_VAR" ]; then TEAM_ID_VAR=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' $RUNNER_TEMP/profile.plist 2>/dev/null || true); fi
        security cms -D -i "$APPDIR/embedded.mobileprovision" \
          | /usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' /dev/stdin \
          | grep -Fx "${TEAM_ID_VAR}.${BUNDLE_ID}"

    - name: Sanity-check IPA payload post-export
      if: success()
      shell: bash
      run: |
        set -e
        IPA=$(ls ${{ runner.temp }}/export-release/*.ipa | head -n 1)
        if [ -z "$IPA" ]; then echo "No IPA to inspect"; exit 0; fi
        TMP=$(mktemp -d)
        unzip -q "$IPA" -d "$TMP"
        APPDIR=$(ls -d "$TMP"/Payload/*.app)
        # must have stdlib zip
        test -f "$APPDIR/python-stdlib.zip"
        # must have Python framework in Frameworks/
        ls "$APPDIR/Frameworks" | grep -i "Python"
        # must include selftest.py
        test -f "$APPDIR/selftest.py"
        # verify final app is signed
        /usr/bin/codesign -dvv "$APPDIR" | grep -E 'Identifier|Authority'

    - name: Clean up keychain
      if: always()
      run: |
        security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

